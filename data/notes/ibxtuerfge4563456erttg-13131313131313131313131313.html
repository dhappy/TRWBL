<h1 id="to-omka--to-lerner-concerning-program-ideas">To @Omka &#x26; to @lerner concerning program ideas<a aria-hidden="true" class="anchor-heading icon-link" href="#to-omka--to-lerner-concerning-program-ideas"></a></h1>
<p>Ok, the online classroom is definitely an idea that's come, but unfortunately that's evidinced by a bunch of serious players on the scene.</p>
<p>I'd like to take a little time &#x26; try to write two apps I've been contemplating for doing local “Find My Device” that would work without Internet.</p>
<p>The core application published an mDNS entry with:
● the port it is listening on with a Quic <em>(HTTP/3)</em> server on both TCP &#x26; UDP
● a nonce it created
● a signature over that port &#x26; nonce from which its public key can be derived</p>
<p>mDNS is broadcast into the local network &#x26; and visible to everyone on the LAN, so anyone local should be able to talk to that server.</p>
<p>I want to then create a Gossipsub network, like is used to back IPFS, to get those machines talking to each other.</p>
<p>So the app listens on its Quic servers, and can receive instruction that are theoretically safe so long as the sanctity of the local network is not compromised.</p>
<p>More sophistocated levels of trust are built on top of the base certainty that you are more than likely dealing with a single persistent other party through time.</p>
<p>So, after Bob proves his identity to Alice through some third party channel <em>(like Signal, you</em> need <em>to install Signal)</em>, she'll know it's him consistently in the future, because all messages are signed with the key Bob included as part of his mDNS entry.</p>
<p><em>(The actual key exchange might involve the peer ids used by IPFS nodes. You can see one in the screenshot below… I'm not sure exactly what they entail. They might just be a public key, but I don't want to just publish a key, it needs to be a signature so I prove I have it.)</em></p>
<p>One of the commands, could be, "play your speaker really loud for ten minutes or until someone picks you up".</p>
<p>There's really two separate programs: one for receiving instructions &#x26; one for sending them. I would like the server to be either a Node.js or Rust application. I'd really like for it to be Rust, intimidating though that be.</p>
<p>One of the core topics in this Gossipsub network are information about updates to the CAR-encoded CBOR DAGs associated with updates to a shared context tree.</p>
<p>Information is dispersed by creating new connections within the network. Rather than transferring files a connection is made within the users context tree providing informed access to some new datum.</p>
<p>The are two options for how the CAR files will be packed. I can <em>either</em> take two DAGs with lots of different changes &#x26; generate the nodes of a CBOR <em>(binary cousin of JSON)</em> DAG where the CAR file is a collection of all those changes in a bundle. This model is something akin to <code>commit</code> points in the <code>git</code> workflow. The alternative is to put each node in it's own CAR file &#x26; insert it independently.</p>
<p>The first way is much more efficient, and it allows related changes to move together. The second, I think, is online traversable in a way the other isn't. Really there's places for both methods.</p>
<p>In any case, these two servers will talk to each other &#x26; exchange some trees of descriptors where <em>all</em> coherent paths are meant to resolve &#x26; partially-coherent paths will generate an ordered list of possibilities.</p>
<p>It's sort of like a normal directory tree, except all the context information is present in the path. You would write <code>.../book/by/Charles Stross/Lobsters/epub.epub</code> or <code>.../book/Charles Stross ― Accelerando/html.html</code> or <code>.../collection/World's Best Science Fiction 1987/4/Charlse Stross ― Overtime</code>. <em>(I have to repeat the extension twice because currently alot of programs get grumpy without them.)</em></p>
<p>This massive DAG that's getting broadcast all over the local network can be used for message passing in a public forum ala. Discord.</p>
<p>You could create a Markdown file and store it in a location like <code>.../messenges/to/@Omka/56/md.md</code> which is also linked to by <code>.../messenges/to/@Omka/2024⁄10⁄29@4ʜ77.337/md.md</code>. One of the programs processing information for the Qwik listeners can watch the network for broadcasts of new additions to a directory when it's alphabetically sorted. <em>(The second date formatted entry alphabetically sorts with newest last, so when a new tail end of the list appears on the network, a program is executed to deliver that message.)</em></p>
<p>I want to do the current notifications bar on the phone with the swipe to dismiss behavior, but I want to make it much more picture oriented.</p>
<p>The particularly interesting software though is to aid with a transaction flow I've been developing for person-to-person transactions. The buyer inputs their offer price, the seller puts in the number of units they want, and a total is calculated. Afterward, the price is then written as <code>&#x3C;amount paid> = &#x3C;market price> - &#x3C;discount> - &#x3C;outstanding debt></code> where <code>&#x3C;market price> = &#x3C;asking price ⅌> * &#x3C;number of units></code>, so Candy did <code>$490 = $497½ - $7½</code> or paid me <code>$490</code> for <code>$497½</code> worth of stuff &#x26; I have a sheet of paper where I wrote the price ⅌ &#x26; she wrote the number taken.</p>
<p>Finally, the seller puts in how much money they verify that they received &#x26; everyone signs the whole transaction.</p>
<p>I want to do a digital version of this, but I'd really like to do a dynamic SVG version where the digital signatures are embedded in an SVG showing the reciept as well as customizably positions individualized logos for the involved parties.</p>
<p>Where I'd really like to go with it is to tie Optimism in as a way to make payments. The receipt could be automatically generated upon reception of a payment to an address. Optimism or Filecoin's network <em>(I like the idea of working in Rust)</em>, or IOTA. <em>(I still think IOTA could be the breakout winner in the crypro wars because it is WASM compatible</em> (like Filecoin) <em>&#x26; it doesn't use a blockchain. Message senders randomly verify some number of messages that came beforehand. The most messages going out the more verifiers.)</em> Definitely Monero. :catsmile:. Something digital.</p>
<p>Ultimately, where I want to go with this is buyer &#x26; seller transact online &#x26;, post payment, the seller drops the purchase into a blind courier network that gets it to the seller.</p>
<p>I'd really like to try and do a Flutter app <em>(which would be written in Dart)</em>. Particularly, I am thinking about trying to do a Dart implementation of the <a href="https://storacha.network">Storacha</a> program <a href="https://github.com/storacha/specs/blob/4163e28d7e6a7c44cff68db9d9bffb9b37707dc6/pail.md"><code>pail</code></a> which is a key-value store distributed as a CBOR DAG. I'm still digging into how it works, but a Dart implementation would let me use it in my Flutter app.</p>
<p>What I was thinking about doing first is a Flutter version of <a href="/">small caps</a> which will give different Unicode equivalents for strings. Like I might type in “small caps” &#x26; it'll give me: . I think maybe it'd be better if my first Flutter app wasn't the DAG transferring program.</p>